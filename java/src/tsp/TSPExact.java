package tsp;

import java.io.FileNotFoundException;
import java.util.ArrayList;

import model.DistanceMatrix;
import util.CSVExporter;
import util.DistanceMatrixImporter;

public class TSPExact {

 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat10.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat11.csv";
	//java.lang.OutOfMemoryError: GC overhead limit exceeded
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat12.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallRealTravelTimes.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallAirDistances.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy30TravelTimes.csv";
	private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy10TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy11TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy12TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy13TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy14TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy15TravelTimes.csv";
	
	
	
	private ArrayList<ArrayList<Integer>> routes = new ArrayList<ArrayList<Integer>>();
	private int[][] routesArray;
	private int arrayIndex;
	private int numberOfPotentialPaths;
	private DistanceMatrix distanceMatrix;
	
	
	public TSPExact(DistanceMatrix distanceMatrix) {
		this.distanceMatrix = distanceMatrix;
		numberOfPotentialPaths = distanceMatrix.getNumberOfPotentialPaths();
		routesArray = new int[numberOfPotentialPaths][distanceMatrix.getDimension()+1];
		arrayIndex = 0;		
	}
	
	public static void main(String[] args) throws Exception {
		
		// benchmarking
		long time = System.currentTimeMillis();
		
		// import csv file
		double[] distanceMatrixEntries = DistanceMatrixImporter.importCSV(distmatFile);
		
		// store in distance matrix
		DistanceMatrix distanceMatrix = new DistanceMatrix(distanceMatrixEntries);
		
		TSPExact solver = new TSPExact(distanceMatrix);
		
		// generate a nodes array
		int[] nodes = new int[distanceMatrix.getDimension()-1];
		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = i+2;
		}
		
		int[] route = new int[distanceMatrix.getDimension() + 1];
		route[0] = 1;
		
		solver.getAllRoutes(nodes, route);
		System.out.println(solver.getRoutesArray().length + " potential routes identified.");
		
		// find shortest round
		int shortestRoundIndex = solver.findShortestRoute();
		// result printing
		System.out.println("Found shortest route:");
		
		String outputString = new String();
		for (Integer i : solver.getRoutesArray()[shortestRoundIndex]) {
			outputString += i + "->";
		}
		outputString = outputString.substring(0, outputString.length()-2);
		System.out.println(outputString);
		System.out.println("Associated distance:");
		double currentDistance = 0;
		int[] currentRoute = solver.getRoutesArray()[shortestRoundIndex];
		for (int j = 0; j < distanceMatrix.getDimension(); j++) {
			currentDistance += distanceMatrix.getEntry(currentRoute[j], currentRoute[j+1]);
		}
		System.out.println(currentDistance+"");
		
		System.out.println("Time consumed: " + (System.currentTimeMillis() - time));
		
		
		CSVExporter.writeNodes("C:\\Users\\Marcus\\Documents\\FPMS\\data\\PerfectSolution.csv", currentRoute);
		String[] cmdarray = new String[6];
		//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
		cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
		cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
		cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
		cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/PerfectSolution.csv";
		cmdarray[4] = "tsp";
		cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExamplePerfectSolution.pdf";
		Process p = Runtime.getRuntime().exec(cmdarray);
	}
	
	public static int[] solveExact(DistanceMatrix distanceMatrix) {
		TSPExact solver = new TSPExact(distanceMatrix);
		
		// generate a nodes array
		int[] nodes = new int[distanceMatrix.getDimension()-1];
		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = i+2;
		}
		
		int[] route = new int[distanceMatrix.getDimension() + 1];
		route[0] = 1;
		
		solver.getAllRoutes(nodes, route);
		
		// find shortest round
		int shortestRoundIndex = solver.findShortestRoute();
		int[] currentRoute = solver.getRoutesArray()[shortestRoundIndex];
		return currentRoute;
	}
	
	/**
	 * @param nodes
	 * @param route
	 * Identifies all potential routes but is faster than the other version and works based on permutation
	 */
	private void getAllRoutes(int[] nodes, int[] route) {
		if (nodes.length == 1) {
			route[route.length-2] = nodes[0];
			route[route.length-1] = 1;
			routesArray[arrayIndex] = route;
			arrayIndex++;
		}
		else {
			for (int i = 0; i < nodes.length; i++) {
				// nodes are all nodes except for the first node (the depot)
				// so if 0 (1) nodes are in the route so far, the next node has to saved at index 1 (2)
				// as the first index is reserved for the depot
				int[] newRoute = new int[route.length];
				
				// find the first entry of the current round that is not determined yet
				int firstZero = -1;
				
				// copy the route to a new array
				for (int j = 0; j < route.length; j++) {
					if (route[j] == 0) {
						firstZero = j;
						break;
					}
					newRoute[j] = route[j];
				}
				
				// copy the remaining nodes to a new array and shrink the array
				newRoute[firstZero] = nodes[i];
				int[] newNodes = new int[nodes.length-1];
				int k = 0;
				for (int j = 0; j < nodes.length; j++) {
					if (i == j) continue;
					else {
						newNodes[k] = nodes[j];
						k++;
					}
				}
				getAllRoutes(newNodes, newRoute);
			}
		}
	}
	
	private int findShortestRoute() {
		double shortestDistance = Double.MAX_VALUE;
		int shortestIndex = -1;
		for (int i = 0; i < routesArray.length; i++) {
			double currentDistance = 0;
			int[] currentRoute = routesArray[i];
			for (int j = 0; j < distanceMatrix.getDimension(); j++) {
				currentDistance += distanceMatrix.getEntry(currentRoute[j], currentRoute[j+1]);
				if (currentDistance > shortestDistance) break;
			}
			if (currentDistance < shortestDistance) {
				shortestDistance = currentDistance;
				shortestIndex = i;
			}
		}
		return shortestIndex;
	}
	
	public ArrayList<ArrayList<Integer>> getRoutes() {
		return routes;
	}
	
	public int[][] getRoutesArray() {
		return routesArray;
	}
}
