package tsp;

import java.io.FileNotFoundException;
import java.util.ArrayList;

import model.DistanceMatrix;
import util.CSVExporter;
import util.DistanceMatrixImporter;

public class TSPExact2 {

 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat10.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat11.csv";
	//java.lang.OutOfMemoryError: GC overhead limit exceeded
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat12.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\DummyDistmat15.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy10TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy11TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy12TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy13TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy14TravelTimes.csv";
	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy15TravelTimes.csv";
 	//private static String distmatFil/e = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallRealTravelTimes.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallAirDistances.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy30TravelTimes.csv";
	
	
	private int[] shortestRoute;
	private double shortestDistance;
	// save the shortest distance between two nodes for brach and bound cutting
	private double shortest;
	
	
	public TSPExact2(DistanceMatrix distanceMatrix) {
		shortestDistance = Double.MAX_VALUE;
		shortest = distanceMatrix.getShortestDistance();
	}
	
	public static void main(String[] args) throws Exception {
		
		// benchmarking
		long time = System.currentTimeMillis();
		
		// import csv file
		int numberOfNodes = 14;
		String distmatFile = null;
		switch (numberOfNodes) {
		case 10:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy10TravelTimes.csv"; break;
		case 11:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy11TravelTimes.csv"; break;
		case 12:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy12TravelTimes.csv"; break;
		case 13:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy13TravelTimes.csv"; break;
		case 14:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy14TravelTimes.csv"; break;
		case 15:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy15TravelTimes.csv"; break;
		}
		double[] distanceMatrixEntries = DistanceMatrixImporter.importCSV(distmatFile);
		
		// store in distance matrix
		DistanceMatrix distanceMatrix = new DistanceMatrix(distanceMatrixEntries);

		TSPExact2 solver = new TSPExact2(distanceMatrix);
		
		// generate a nodes array
		int[] nodes = new int[distanceMatrix.getDimension()-1];
		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = i+2;
		}
		
		int[] route = new int[distanceMatrix.getDimension() + 1];
		route[0] = 1;
		
		solver.getAllRoutes(distanceMatrix, nodes, route, 1);
		System.out.println("Shortest route: ");
		for (int i = 0; i < solver.getShortestRoute().length-1; i++) {
			System.out.print(solver.getShortestRoute()[i] + "->");
		}
		System.out.println(solver.getShortestRoute()[solver.getShortestRoute().length-1]);
		System.out.println("Associated distance:");
		System.out.println(TSPHelper.getRouteCosts(distanceMatrix, solver.getShortestRoute()));
		
		System.out.println("Time consumed: " + (System.currentTimeMillis() - time));
		
		CSVExporter.writeNodes("C:\\Users\\Marcus\\Documents\\FPMS\\data\\PerfectSolution.csv", solver.getShortestRoute());
		String[] cmdarray = new String[6];
		//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
		cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
		cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
		cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/DummyLonLats" + numberOfNodes + ".csv";
		cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/PerfectSolution.csv";
		cmdarray[4] = "tsp";
		cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExamplePerfectSolution";
		Process p = Runtime.getRuntime().exec(cmdarray);
	}
	
	public static int[] solveExact(DistanceMatrix distanceMatrix) {
		TSPExact2 solver = new TSPExact2(distanceMatrix);
		
		// generate a nodes array
		int[] nodes = new int[distanceMatrix.getDimension()-1];
		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = i+2;
		}
		
		int[] route = new int[distanceMatrix.getDimension() + 1];
		route[0] = 1;
		
		solver.getAllRoutes(distanceMatrix, nodes, route, 1);
		
		// find shortest round
		return solver.getShortestRoute();
	}
	
	/**
	 * @param nodes
	 * @param route
	 * Identifies all potential routes but is faster than the other version and works based on permutation
	 */
	private void getAllRoutes(DistanceMatrix distanceMatrix, int[] nodes, int[] route, int currentLength) {
		
		// if shortest distance is exceeded already, cancel this branch of search
		// additionally add the shortest overall matrix entry times the number of remaining steps in the route
		double routeCosts = TSPHelper.getRouteCosts(distanceMatrix, route);
		if (routeCosts + (shortest * (route.length - currentLength))> shortestDistance) return;
		else if (nodes.length == 1) {
			route[route.length-2] = nodes[0];
			route[route.length-1] = 1;
			routeCosts = routeCosts + distanceMatrix.getEntry(route[route.length-3], route[route.length-2]) + 
					distanceMatrix.getEntry(route[route.length-2], route[route.length-1]);
			if (routeCosts < shortestDistance) {
				shortestDistance = routeCosts;
				shortestRoute = route;
			}
		}
		else {
			for (int i = 0; i < nodes.length; i++) {
				// nodes are all nodes except for the first node (the depot)
				// so if 0 (1) nodes are in the route so far, the next node has to saved at index 1 (2)
				// as the first index is reserved for the depot
				int[] newRoute = new int[route.length];
				
				// copy the route to a new array
				for (int j = 0; j < currentLength; j++) {
					if (route[j] == 0) {
						break;
					}
					newRoute[j] = route[j];
				}
				
				// copy the remaining nodes to a new array and shrink the array
				newRoute[currentLength] = nodes[i];
				int[] newNodes = new int[nodes.length-1];
				int k = 0;
				for (int j = 0; j < nodes.length; j++) {
					if (i == j) continue;
					else {
						newNodes[k] = nodes[j];
						k++;
					}
				}
				getAllRoutes(distanceMatrix, newNodes, newRoute, currentLength + 1);
			}
		}
	}
	
	public int[] getShortestRoute() {
		return shortestRoute;
	}
}
