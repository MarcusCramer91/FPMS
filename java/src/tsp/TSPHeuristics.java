package tsp;

import java.io.IOException;
import java.util.ArrayList;

import model.DistanceMatrix;
import util.CSVExporter;
import util.DistanceMatrixImporter;
import util.Graph;
import util.LonLatImporter;
import util.Permutation;

public class TSPHeuristics {

 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallRealTravelTimes.csv";
 	//private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\SmallAirDistances.csv";
 	private static String distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy30TravelTimes.csv";
 	

	private DistanceMatrix distanceMatrix;
	private int[][] eulerianPath;
	
	private static boolean generatePlots = false;
	private static boolean verbose = false;
	
	public TSPHeuristics(DistanceMatrix distanceMatrix) {
		this.distanceMatrix = distanceMatrix;
	}
	
	public static void main(String[] args) throws Exception {
			
		// benchmarking
		long time = System.currentTimeMillis();
		
		// import csv file
		int numberOfNodes = 15;
		String distmatFile = null;
		switch (numberOfNodes) {
			case 10:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy10TravelTimes.csv"; break;
			case 11:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy11TravelTimes.csv"; break;
			case 12:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy12TravelTimes.csv"; break;
			case 13:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy13TravelTimes.csv"; break;
			case 14:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy14TravelTimes.csv"; break;
			case 15:  distmatFile = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\Dummy15TravelTimes.csv"; break;
		}
		double[] distanceMatrixEntries = DistanceMatrixImporter.importCSV(distmatFile);
		// store in distance matrix
		DistanceMatrix distanceMatrix = new DistanceMatrix(distanceMatrixEntries);
		
		//TSPHeuristics solver = new TSPHeuristics(distanceMatrix);
		// compute the minimum spanning tree
		int[][] mst = TSPHeuristics.constructMinimumSpanningTree(distanceMatrix);
		if (verbose) {
			System.out.println("Minimum spanning tree:");
			for (int i = 0; i < mst[0].length; i++) {
				System.out.println(mst[0][i] + "->" + mst[1][i]);
			}
		}
		
		if (TSPHeuristics.generatePlots) {
			// generate R plot
			CSVExporter.writeEdges("C:\\Users\\Marcus\\Documents\\FPMS\\data\\MSTEdges.csv", mst);
			
			String[] cmdarray = new String[6];
			//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
			cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
			cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/MSTEdges.csv";
			cmdarray[4] = "mst";
			cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExampleMST.pdf";
			Process p = Runtime.getRuntime().exec(cmdarray);
			// give r time to finish the process
			//p.waitFor();
		}
		// create a temporary distance matrix with the only nodes being those with an odd number of outgoing edges in the MST
		int[] edgesPerNode = new int[distanceMatrix.getDimension()];
		for (int i = 0; i < mst[0].length; i++) {
			edgesPerNode[mst[0][i]-1]++;
			edgesPerNode[mst[1][i]-1]++;
		}
		ArrayList<Integer> oddNodes = new ArrayList<Integer>();
		for (int i = 0; i< edgesPerNode.length; i++) {
			if (edgesPerNode[i] % 2 == 1) oddNodes.add(i+1);
		}
		
		if (verbose) {
			if (oddNodes.size() > 0) System.out.println("Nodes with an odd amount of outgoing edges found:");
			for (int i = 0; i < oddNodes.size(); i++) {
				System.out.println(oddNodes.get(i) + "");
			}
		}
		
		// solve minimum weight matching via brute force
		// check if number of odd nodes exceeds 10, then brute force is no longer viable 
		// as complexity class lies in the same class as the TSP
		// generate an array of all nodes first
		int[] oddNodesArray = new int[oddNodes.size()];
		for (int i = 0; i < oddNodes.size(); i++) {
			oddNodesArray[i] = oddNodes.get(i);
		}
		int[][] minimumWeightMatching;
		if (oddNodes.size() > 9) {
			minimumWeightMatching = TSPHeuristics.constructMinimumWeightMatchingGreedy(distanceMatrix, oddNodesArray, mst);
		}
		else {
			// get all permutations
			Permutation permutator = new Permutation(oddNodesArray);
			int[] temp = new int[oddNodes.size()];
			permutator.generatePermutations(temp, oddNodesArray);
			ArrayList<int[]> allPermutations = permutator.getPermutations();
			
			// delete every second permutation (they are equivalent for our purpose, 
			// as a b c d 1 2 leads to the same edges as a b c d 2 1
			for (int i = (allPermutations.size()-1); i > 0; i = i - 2) {
				allPermutations.remove(i);
			}
			if (verbose) {
				System.out.println(allPermutations.size() + " relevant permutations found for the minimum weight matching.");
			}
			minimumWeightMatching = TSPHeuristics.constructMinimumWeightMatchingBruteForce(distanceMatrix, allPermutations, mst);
		}
		
		if (verbose) {
			System.out.println("Identified following minimum weight matching edges");
			for (int i = 0; i < minimumWeightMatching[0].length; i++) {
				System.out.println(minimumWeightMatching[0][i] + "->" + minimumWeightMatching[1][i]);
			}
		}
		int[][] allEdges = new int[2][mst[0].length + minimumWeightMatching[0].length];
		int i;
		for (i = 0; i < mst[0].length; i++) {
			allEdges[0][i] = mst[0][i];
			allEdges[1][i] = mst[1][i];
		}
		for (int j = 0; j < minimumWeightMatching[0].length; j++) {
			allEdges[0][i] = minimumWeightMatching[0][j];
			allEdges[1][i] = minimumWeightMatching[1][j];
			i++;
		}

		if (TSPHeuristics.generatePlots) {
		// generate R plot
			CSVExporter.writeEdges("C:\\Users\\Marcus\\Documents\\FPMS\\data\\MWMEdges.csv", allEdges);
			
			String[] cmdarray = new String[6];
			cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
			cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
			cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/MWMEdges.csv";
			cmdarray[4] = "mwm";
			cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExampleMinimumWeight.pdf";
			Runtime.getRuntime().exec(cmdarray);
			Process p = Runtime.getRuntime().exec(cmdarray);
			// give r time to finish the process
			//p.waitFor();
		}
		// now generate Eulerian path
		TSPHeuristics tspHeuristics = new TSPHeuristics(distanceMatrix);
		tspHeuristics.constructEulerianPath(allEdges);
		int[][] eulerianPath = tspHeuristics.getEulerianPath();
		if (verbose) {
			System.out.println("Identified following Eulerian path");
			for (i = 0; i < eulerianPath[0].length; i++) {
				System.out.println(eulerianPath[0][i] + "->" + eulerianPath[1][i]);
			}
		}

		if (TSPHeuristics.generatePlots) {
			CSVExporter.writeEdges("C:\\Users\\Marcus\\Documents\\FPMS\\data\\EulerianEdges.csv", eulerianPath);
			
			String[] cmdarray = new String[6];
			//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
			cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
			cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/EulerianEdges.csv";
			cmdarray[4] = "euler";
			cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExampleEulerianPath.pdf";
			Process p = Runtime.getRuntime().exec(cmdarray);
		}
		// now remove redundant nodes and arrange visiting sequence
		int[] nodeSequence = new int[distanceMatrix.getDimension()+1];
		nodeSequence[0] = eulerianPath[0][0];
		int counter = 1;
		int previousNode = eulerianPath[0][0];
		for (i = 0; i < eulerianPath[0].length; i++) {
			int nextNode;
			if (eulerianPath[0][i] == previousNode) {
				nextNode = eulerianPath[1][i];
			}
			else nextNode = eulerianPath[0][i];
			if (!TSPHelper.containsNode(nodeSequence, nextNode)) {
				nodeSequence[counter] = nextNode;
				counter++;
			}
			previousNode = nextNode;
		}
		
		// add last node
		nodeSequence[nodeSequence.length-1] = eulerianPath[0][0];	
		
		// rearrange order so that tour starts at 1 and begins at 1
		int[] nodeSequenceRearranged = new int[nodeSequence.length];
		counter = 0;
		boolean foundOne = false;
		for (i = 0; i < nodeSequence.length; i++) {
			if (nodeSequence[i] == 1 || foundOne) {
				foundOne = true;
				nodeSequenceRearranged[counter] = nodeSequence[i];
				counter++;
			}
		}
		i = 1;
		while (counter < nodeSequence.length-1) {
			nodeSequenceRearranged[counter] = nodeSequence[i];
			counter++;
			i++;
		}
		nodeSequenceRearranged[nodeSequenceRearranged.length-1] = 1;
		nodeSequence = nodeSequenceRearranged;
		
		// check which direction results in shorter travel times
		double time1 = TSPHelper.getRouteCosts(distanceMatrix, nodeSequence);
		int[] nodeSequenceInverted = new int[nodeSequence.length];
		counter = 0;
		for (i = nodeSequence.length-1; i >= 0; i--) {
			nodeSequenceInverted[counter] = nodeSequence[i];
			counter++;
		}
		double time2 = TSPHelper.getRouteCosts(distanceMatrix, nodeSequenceInverted);
		if (time2 < time1) nodeSequence = nodeSequenceInverted;
		
		if (verbose) {
			System.out.println("Resulting initial TSP solution is:");
			for (i = 0; i < nodeSequence.length-1; i++) {
				System.out.print(nodeSequence[i] + "->");
			}
			System.out.print(nodeSequence[nodeSequence.length-1] + "\n");
			System.out.println("Resulting initial costs: " + time1);		
		}

		if (TSPHeuristics.generatePlots) {
			CSVExporter.writeNodes("C:\\Users\\Marcus\\Documents\\FPMS\\data\\InitialSolution.csv", nodeSequence);
			
			String[] cmdarray = new String[6];
			//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
			cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
			cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
			cmdarray[3] = "C:/Users/Marcus/Documents/FPMS/data/InitialSolution.csv";
			cmdarray[4] = "tsp";
			cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/ExampleInitialSolution.pdf";
			Process p = Runtime.getRuntime().exec(cmdarray);
		}
		// start local optimization procedures
		nodeSequence = tspHeuristics.twoOpt(nodeSequence, distanceMatrix, TSPHeuristics.generatePlots);
		System.out.println("Resulting TSP solution is:");
		for (i = 0; i < nodeSequence.length-1; i++) {
			System.out.print(nodeSequence[i] + "->");
		}
		System.out.print(nodeSequence[nodeSequence.length-1] + "\n");
		double newCosts = TSPHelper.getRouteCosts(distanceMatrix, nodeSequence);
		System.out.println("Resulting new costs: " + newCosts);

		System.out.println("Time consumed: " + (System.currentTimeMillis() - time));
	}
	
	public static int[] solveTSP(DistanceMatrix distanceMatrix) throws Exception {
		// create minimum spanning tree
		int[][] mst = TSPHeuristics.constructMinimumSpanningTree(distanceMatrix);
		
		// create a temporary distance matrix with the only nodes being those with an odd number of outgoing edges in the MST
		int[] edgesPerNode = new int[distanceMatrix.getDimension()];
		for (int i = 0; i < mst[0].length; i++) {
			edgesPerNode[mst[0][i]-1]++;
			edgesPerNode[mst[1][i]-1]++;
		}
		ArrayList<Integer> oddNodes = new ArrayList<Integer>();
		for (int i = 0; i< edgesPerNode.length; i++) {
			if (edgesPerNode[i] % 2 == 1) oddNodes.add(i+1);
		}
		
		// generate an array of all nodes first
		int[] oddNodesArray = new int[oddNodes.size()];
		for (int i = 0; i < oddNodes.size(); i++) {
			oddNodesArray[i] = oddNodes.get(i);
		}
		
		// solve exact only for less than 10 nodes (otherwise, this step takes too long)
		int[][] minimumWeightMatching;
		if (oddNodes.size() > 9) {
			minimumWeightMatching = TSPHeuristics.constructMinimumWeightMatchingGreedy(distanceMatrix, oddNodesArray, mst);
		}
		else {
			// get all permutations
			Permutation permutator = new Permutation(oddNodesArray);
			int[] temp = new int[oddNodes.size()];
			permutator.generatePermutations(temp, oddNodesArray);
			ArrayList<int[]> allPermutations = permutator.getPermutations();
			// delete every second permutation (they are equivalent for our purpose, 
			// as a b c d 1 2 leads to the same edges as a b c d 2 1
			for (int i = (allPermutations.size()-1); i > 0; i = i - 2) {
				allPermutations.remove(i);
			}
			minimumWeightMatching = TSPHeuristics.constructMinimumWeightMatchingBruteForce(distanceMatrix, allPermutations, mst);
		}
		
		int[][] allEdges = new int[2][mst[0].length + minimumWeightMatching[0].length];
		int i;
		for (i = 0; i < mst[0].length; i++) {
			allEdges[0][i] = mst[0][i];
			allEdges[1][i] = mst[1][i];
		}
		for (int j = 0; j < minimumWeightMatching[0].length; j++) {
			allEdges[0][i] = minimumWeightMatching[0][j];
			allEdges[1][i] = minimumWeightMatching[1][j];
			i++;
		}
		// now generate Eulerian path
		TSPHeuristics tspHeuristics = new TSPHeuristics(distanceMatrix);
		tspHeuristics.constructEulerianPath(allEdges);
		int[][] eulerianPath = tspHeuristics.getEulerianPath();
		// now remove redundant nodes and arrange visiting sequence
		int[] nodeSequence = new int[distanceMatrix.getDimension()+1];
		nodeSequence[0] = eulerianPath[0][0];
		int counter = 1;
		int previousNode = eulerianPath[0][0];
		for (i = 0; i < eulerianPath[0].length; i++) {
			int nextNode;
			if (eulerianPath[0][i] == previousNode) {
				nextNode = eulerianPath[1][i];
			}
			else nextNode = eulerianPath[0][i];
			if (!TSPHelper.containsNode(nodeSequence, nextNode)) {
				nodeSequence[counter] = nextNode;
				counter++;
			}
			previousNode = nextNode;
		}
		
		// add last node
		nodeSequence[nodeSequence.length-1] = eulerianPath[0][0];
		// rearrange order so that tour starts at 1 and begins at 1
		int[] nodeSequenceRearranged = new int[nodeSequence.length];
		counter = 0;
		boolean foundOne = false;
		for (i = 0; i < nodeSequence.length; i++) {
			if (nodeSequence[i] == 1 || foundOne) {
				foundOne = true;
				nodeSequenceRearranged[counter] = nodeSequence[i];
				counter++;
			}
		}
		i = 1;
		while (counter < nodeSequence.length-1) {
			nodeSequenceRearranged[counter] = nodeSequence[i];
			counter++;
			i++;
		}
		nodeSequenceRearranged[nodeSequenceRearranged.length-1] = 1;
		nodeSequence = nodeSequenceRearranged;
		
		// check which direction results in shorter travel times
		double time1 = TSPHelper.getRouteCosts(distanceMatrix, nodeSequence);
		int[] nodeSequenceInverted = new int[nodeSequence.length];
		counter = 0;
		for (i = nodeSequence.length-1; i >= 0; i--) {
			nodeSequenceInverted[counter] = nodeSequence[i];
			counter++;
		}
		double time2 = TSPHelper.getRouteCosts(distanceMatrix, nodeSequenceInverted);
		if (time2 < time1) nodeSequence = nodeSequenceInverted;
		// start local optimization procedures
		nodeSequence = tspHeuristics.twoOpt(nodeSequence, distanceMatrix, false);
		double newCosts = TSPHelper.getRouteCosts(distanceMatrix, nodeSequence);
		return nodeSequence;
	}
	
	private static int[][] constructMinimumSpanningTree(DistanceMatrix distanceMatrix) {
		double[] oldEntries = distanceMatrix.getAllEntries();
		double[] newEntries = new double[distanceMatrix.getAllEntries().length];
		for (int i = 0; i < newEntries.length; i++) {
			newEntries[i] = oldEntries[i];
		}
		DistanceMatrix distanceMatrixCopy = new DistanceMatrix(newEntries);
		int dimension = distanceMatrix.getDimension();
		int[][] result = new int[2][dimension-1];
		// save current spanning forests
		ArrayList<ArrayList<Integer>> spanningForest = new ArrayList<ArrayList<Integer>>();
		
		// in the beginning all forests consist of just one element
		for (int i = 1; i <= dimension; i++) {
			ArrayList<Integer> tree = new ArrayList<Integer>();
			tree.add(i);
			spanningForest.add(tree);
		}
		
		for (int i = 0; i < dimension-1; i++) {
			int[] minimumEdge = findMinimumEdge(distanceMatrixCopy);
			
			// set used edge to maximum value, so that it won't be used again
			distanceMatrixCopy.setEntry(Double.MAX_VALUE, minimumEdge[0], minimumEdge[1]);
			distanceMatrixCopy.setEntry(Double.MAX_VALUE, minimumEdge[1], minimumEdge[0]);
			
			// check whether both connected points are already in the same tree
			// this would form a circle
			int j;
			for (j = 0; j < spanningForest.size(); j++) {
				if (spanningForest.get(j).contains(new Integer(minimumEdge[0]))) {
					break;
				}
			}
			int k;
			for (k = 0; k < spanningForest.size(); k++) {
				if (spanningForest.get(k).contains(new Integer(minimumEdge[1]))) {
					break;
				}
			}
			
			// if they are in the same tree, this would form a circuit
			// redo the current loop iteration
			if (j == k) i--;

			// else add to solution and merge trees
			else {
				result[0][i] = minimumEdge[0];
				result[1][i] = minimumEdge[1];
				ArrayList<Integer> newTree = new ArrayList<Integer>();
				for (int l = 0; l < spanningForest.get(j).size(); l++) {
					newTree.add(spanningForest.get(j).get(l));
				}
				for (int l = 0; l < spanningForest.get(k).size(); l++) {
					newTree.add(spanningForest.get(k).get(l));
				}
				spanningForest.remove(j);
				if (k > j) spanningForest.remove(k-1);
				else spanningForest.remove(k);
				spanningForest.add(newTree);
			}
		}
		return result;
	}
	
	private static int[] findMinimumEdge(DistanceMatrix distanceMatrix) {
		int dimension = distanceMatrix.getDimension();
		double minimum = Double.MAX_VALUE;
		int row = -1;
		int column = -1;
		double[] allEntries = distanceMatrix.getAllEntries();
		int counter = 0;
		for (int i = 1; i <= dimension; i++) {
			for (int j = 1; j <= dimension; j++) {
				if (i == j) {
					counter++;
					continue;
				}
				if (allEntries[counter] < minimum) {
					row = i;
					column = j;
					minimum = allEntries[counter];
				}
				counter++;
			}
		}
		int[] result = {row, column};
		return result;
	}
	
	private static int[][] constructMinimumWeightMatchingBruteForce(DistanceMatrix distanceMatrix, ArrayList<int[]> allPermutations, 
			int[][] existingEdges) {
		double minimumCosts = Double.MAX_VALUE;
		int bestPermutationIndex = -1;
		int[][] result = new int[2][allPermutations.get(0).length/2];
		for (int i = 0; i < allPermutations.size(); i++) {
			double currentCosts = 0;
			boolean edgeExists = false;
			for (int j = 0; j < allPermutations.get(0).length; j = j + 2) {
				// check if edge already exists
				if (TSPHelper.containsEdge(existingEdges, allPermutations.get(i)[j], allPermutations.get(i)[j+1])) {
					edgeExists = true;
					break;
				}
				currentCosts += distanceMatrix.getEntry(allPermutations.get(i)[j], allPermutations.get(i)[j+1]);
			}
			if (edgeExists) continue;
			if (currentCosts < minimumCosts) {
				minimumCosts = currentCosts;
				bestPermutationIndex = i;
			}
		}
		int counter = 0;
		for (int i = 0; i < allPermutations.get(0).length; i = i + 2) {
			result[0][counter] = allPermutations.get(bestPermutationIndex)[i];
			result[1][counter] = allPermutations.get(bestPermutationIndex)[i+1];
			counter++;
		}
		return result;
	}
	
	private void constructEulerianPath(int[][] allEdges) {
		this.eulerianPath = new int[2][allEdges[0].length];
		int[][] previousEdges = new int[2][0];
		constructEulerianPathRecursive(allEdges, previousEdges, allEdges[0][0]);	
	}
	
	private void constructEulerianPathRecursive(int[][] allEdges, int[][] previousEdges, int currentNodeIndex) {
		// recursive anchor: length of previous edges == length of all edges
		if (allEdges[0].length == previousEdges[0].length) this.eulerianPath = previousEdges;
		
		// find edges outgoing from the current node
		ArrayList<Integer> relevantEdgesIndices = new ArrayList<Integer>();
		for (int i = 0; i < allEdges[0].length; i++) {
			// if edge is connected to current node and has not been traveled yet
			if ((allEdges[0][i] == currentNodeIndex || allEdges[1][i] == currentNodeIndex) && 
					!TSPHelper.containsEdge(previousEdges, allEdges[0][i], allEdges[1][i])) relevantEdgesIndices.add(i);
		}
		
		// if no outgoing edges exist from this node cancel current recursion
		if (relevantEdgesIndices.size() == 0) return;
		// else build a path from all outgoing edges
		for (int i = 0; i < relevantEdgesIndices.size(); i++) {
			// check whether a solution for the eulerian path is already found
			if (this.eulerianPath[0][0] != 0) return;
			
			// build new previous edges array extended by the current relevant next edge
			int[][] newPreviousEdges = new int[2][previousEdges[0].length+1];
			for (int j = 0; j < previousEdges[0].length; j++) {
				newPreviousEdges[0][j] = previousEdges[0][j];
				newPreviousEdges[1][j] = previousEdges[1][j];
			}
			newPreviousEdges[0][newPreviousEdges[0].length-1] = allEdges[0][relevantEdgesIndices.get(i)];
			newPreviousEdges[1][newPreviousEdges[0].length-1] = allEdges[1][relevantEdgesIndices.get(i)];
			
			// recursive step
			int nextNodeIndex = allEdges[0][relevantEdgesIndices.get(i)];
			if (nextNodeIndex == currentNodeIndex) nextNodeIndex = allEdges[1][relevantEdgesIndices.get(i)];
			constructEulerianPathRecursive(allEdges, newPreviousEdges, nextNodeIndex);
		}
	}
	
	public int[][] getEulerianPath() {
		return this.eulerianPath;
	}
	
	private int[] twoOpt(int[] tour, DistanceMatrix distanceMatrix, boolean verbose) throws IOException {
		double currentDistance = TSPHelper.getRouteCosts(distanceMatrix, tour);
		
		// cannot swap the depot
		boolean improvement = true;
		int improvementCounter = 0;
		while (improvement) {
			improvement = false;
			boolean next = false;
			for (int i = 1; i < tour.length - 3; i++) {
				if (next) break;
				for (int j = i + 1; j < tour.length - 2; j++) {
					int[] newTour = swapTwoOpt(tour, i, j);
					double newDistance = TSPHelper.getRouteCosts(distanceMatrix, newTour);
					if (newDistance < currentDistance) {
						if (verbose) System.out.println("Improvement found. New route:");
						improvementCounter++;

						if (verbose) {
							CSVExporter.writeNodes("C:\\Users\\Marcus\\Documents\\FPMS\\data\\2OptImprovement" + improvementCounter +
									 ".csv", newTour);
							String[] cmdarray = new String[6];
							//cmdarray[0] = "Rscript C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
							cmdarray[0] = "\"C:\\Program Files\\R\\R-3.3.2\\bin\\Rscript.exe\"";
							cmdarray[1] = "C:\\Users\\Marcus\\Documents\\FPMS\\source\\R\\TSPPlotting.R";
							cmdarray[2] = "C:/Users/Marcus/Documents/FPMS/data/ExampleLonLats.csv";
							cmdarray[3] = "C:\\Users\\Marcus\\Documents\\FPMS\\data\\2OptImprovement" + improvementCounter +
									 ".csv";
							cmdarray[4] = "tsp";
							cmdarray[5] = "C:/Users/Marcus/Documents/FPMS/images/autoGenerated/Example2OptSolution" + improvementCounter + ".pdf";
							Process p = Runtime.getRuntime().exec(cmdarray);
						}
						if (verbose) {
							for (int k = 0; k < newTour.length-1; k++) {
							System.out.print(newTour[k] + "->");
							}
						}
						
						if (verbose) System.out.print(newTour[newTour.length-1] + "\n");
						currentDistance = newDistance;
						tour = newTour;
						improvement = true;
						next = true;
						break;
					}
				}
			}
		}
		return tour;
	}
	
	private int[] swapTwoOpt(int[] tour, int i, int j) {
		int[] newTour = new int[tour.length];
		for (int k = 0; k < i; k++) {
			newTour[k] = tour[k];
		}
		int counter = i;
		for (int k = j; k >=i; k--) {
			newTour[counter] = tour[k];
			counter++;
		}
		for (int k = j+1; k < tour.length; k++) {
			newTour[k] = tour[k];
		}
		return newTour;
	}
	
	
	public static int[][] constructMinimumWeightMatchingGreedy(DistanceMatrix distanceMatrix, int[] oddNodes, int[][] existingEdges) {
		ArrayList<Integer> takenNodes = new ArrayList<Integer>();
		int[][] matching = new int[2][oddNodes.length/2];
		int index = 0;
		while(takenNodes.size() != oddNodes.length) {
			double smallestDistance = Double.MAX_VALUE;
			int smallestI = -1;
			int smallestJ = -1;
			for (int i = 0; i < oddNodes.length; i++) {
				for (int j = 0; j < oddNodes.length; j++) {
					if (i == j) continue;
					if (!TSPHelper.containsNodeInList(takenNodes, oddNodes[i]) && 
							!TSPHelper.containsNodeInList(takenNodes, oddNodes[j]) &&
							!TSPHelper.edgeExists(existingEdges, oddNodes[i], oddNodes[j])) {
						if (distanceMatrix.getEntry(oddNodes[i], oddNodes[j]) < smallestDistance) {
							smallestDistance = distanceMatrix.getEntry(oddNodes[i], oddNodes[j]);
							smallestI = i;
							smallestJ = j;
						}
					}
				}
			}
			matching[0][index] = oddNodes[smallestI];
			matching[1][index] = oddNodes[smallestJ];
			index++;
			takenNodes.add(oddNodes[smallestI]);
			takenNodes.add(oddNodes[smallestJ]);
		}
		return matching;
	}
}
